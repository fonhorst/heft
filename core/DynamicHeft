from functools import partial
from environment.EventAutomata import TaskFinished, node_performance_changed, NodePerformanceChanged, TaskFailed
from environment.Resource import Node
from environment.ResourceManager import Algorithm, Schedule, ScheduleItem
from environment.Utility import reverse_dict
from core.HeftHelper import HeftHelper


class DynamicHeft(Algorithm):
    executed_tasks = set()
    def __init__(self, workflow, resource_manager, estimator):
        self.current_schedule = Schedule(dict())
        self.workflow = workflow
        self.resource_manager = resource_manager
        self.estimator = estimator
        self.wf_jobs = None
        self.make_ranking()
        pass

    def compcost(self, job, agent):
        return self.estimator.estimate_runtime(job, agent)

    def commcost(self, ni, nj, A, B):
        return self.estimator.estimate_transfer_time(A, B, ni, nj)

    def make_ranking(self):
        resources = self.resource_manager.get_resources()
        ##print("common nodes count:" + str(len(toNodes(resources))))
        nodes = HeftHelper.to_nodes(resources)
        ranking_func = HeftHelper.build_ranking_func(nodes, self.compcost, self.commcost)
        self.wf_jobs = ranking_func(self.workflow)
        pass

    def get_ready_tasks(self, task):
        self.executed_tasks.add(task.id)
        def check_parents(child):
            finished_parents = [p for p in child.parents if p.id in self.executed_tasks]
            return len(finished_parents) == len(child.parents)
        return [child for child in task.children if check_parents(child)]

    def run(self, event):
        if isinstance(event, TaskFinished):
            # normal ending
            self.check_finished(self.current_schedule, event)
            # get new ready tasks
            ready_tasks = self.get_ready_tasks(event.task)
            # build new schedule
            self.current_schedule = self.mapping(ready_tasks, self.current_schedule)
            return self.current_schedule
        if isinstance(event, NodePerformanceChanged):
            # clean all unstarted tasks and place it to ready_tasks
            unstarted = self.clean_unstarted_tasks(self.current_schedule)
            ready_tasks = unstarted
            # change current performance of the node
            self.resource_manager.change(event)
            # recalc mapping
            self.current_schedule = self.mapping(ready_tasks, self.current_schedule)
            return self.current_schedule
        if isinstance(event, TaskFailed):
            # clean all unstarted tasks and place it to ready_tasks
            unstarted = self.clean_unstarted_tasks(self.current_schedule)
            ready_tasks = unstarted
            # remove node from nodes
            ##TODO: make it
            ##self.resource_manager.change(TaskFailed)
            # recalc mapping
            self.current_schedule = self.mapping(ready_tasks, self.current_schedule)
            return self.current_schedule
        return None

    def clean_unstarted_tasks(self, schedule):
        lst_unstarted = []
        new_map = dict()
        for (node, items) in schedule.mapping.items():
            normal = []
            for item in items:
                if item.state == ScheduleItem.UNSTARTED:
                    lst_unstarted.append(item)
                else:
                    normal.append(item)
            new_map[item] = normal
        schedule.mapping = new_map
        return lst_unstarted

    def check_finished(self, schedule, TaskFinished):
        sc_item = None
        for (node, items) in schedule.mapping.items():
            for item in items:
                if item.job.id == TaskFinished.task.id:
                    sc_item = item
                    break
        sc_item.state = ScheduleItem.UNSTARTED

    def mapping(self, ready_tasks, existing_mapping):

        jobson = dict()

        new_plan = existing_mapping


        def ft(machine):
            cost = st(machine) + self.compcost(task, machine)
            ##print("machine: %s job:%s cost: %s" % (machine.name, task.id, cost))
            return cost

        wf_dag = HeftHelper.convert_to_parent_children_map(self.workflow)
        prec = reverse_dict(wf_dag)

        for task in ready_tasks:
            st = partial(self.start_time, task, new_plan, jobson, prec, self.commcost)

            agent = min(new_plan.keys(), key=ft)

            start = st(agent)
            end = ft(agent)

            new_plan[agent].append(ScheduleItem(task, start, end))
            jobson[task] = agent

        new_sched = Schedule(new_plan)
        return new_sched

    def start_time(self, task, orders, jobson, prec, commcost, node):

        ## check if soft satisfy requirements
        if self.can_be_executed(node, task):
            ## static or running virtual machine
            if node.state is not Node.Down:
                agent_ready = orders[node][-1].end_time if orders[node] else 0
                if task in prec:
                    comm_ready = max([self.endtime(p, orders[jobson[p]])
                                      + commcost(p, task, node, jobson[p]) for p in prec[task]])
                else:
                    comm_ready = 0
                return max(agent_ready, comm_ready)
        else:
            return 1000000

    def can_be_executed(self, node, job):
        ## check it
        return (job.soft_reqs in node.soft) or (SoftItem.ANY_SOFT in node.soft)

    def endtime(self, job, events):
        """ Endtime of job in list of events """
        for e in events:
            if e.job == job:
                return e.end_time
