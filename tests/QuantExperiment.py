__author__ = 'Николай'

import unittest
from unittest import TestCase
from environment.Utility import Utility
from onlinedvmheft.simple_heft import StaticHeftPlanner
from environment.Resource import ResourceGenerator
from environment.ResourceManager import Estimator
from environment.ResourceManager import ResourceManager
import cProfile, pstats, io


class ExperimentEstimator(Estimator):
    def __init__(self, transferMx):
        self.transfer_matrix = transferMx
        self.cache = dict()

    ##get estimated time of running the task on the node
    def estimate_runtime(self, task, node):
        return task.runtime/node.flops

    ## estimate transfer time between node1 and node2 for data generated by the task
    def estimate_transfer_time(self, node1, node2, task1, task2):
        per_unit_of_time = 1
        ##per_unit_of_time = self.transfer_matrix[node1.name][node2.name]
        ##TODO: it doesn't account non-task's input files. Add it later.
        return self.get_or_estimate(task1, task2)/per_unit_of_time

    def get_or_estimate(self, task1, task2):
        ##TODO: refactor it later
        if self.cache.get(task1, None) is not None:
            if self.cache[task1].get(task2, None) is not None:
               return self.cache[task1][task2]
            else:
                self.cache[task1][task2] = None
        else:
            self.cache[task1] = {task2: None}
        def get_transfer_time(name):
            file = task1.output_files.get(name, None)
            return 0 if file is None else file.size
        ##TODO: correct it later
        """get_transfer_time(name)"""
        list = [ 0 for (name, file) in task2.input_files.items()]
        result = 0##sum()
        self.cache[task1][task2] = result
        return result

    ## estimate probability of successful ending of the task on the node
    def estimate_reliability(self, task, node):
        pass

class ExperimentResourceManager(ResourceManager):
    def __init__(self,resources):
        self.resources = resources

    ##get all resources in the system
    def get_resources(self):
        return self.resources

def wrap():
    ##Preparing
    ut = Utility()

    dax1 = '..\\resources\\Montage_25.xml'
    dax2 = '..\\resources\\CyberShake_30.xml'

    wf_start_id_1 = "00"
    task_postfix_id_1 = "00"

    wf_start_id_2 = "10"
    task_postfix_id_2 = "10"

    deadline_1 = 1000
    deadline_2 = 3000

    pipeline_1 = ut.generateUrgentPipeline(dax1,
                                           wf_start_id_1,
                                           task_postfix_id_1,
                                           deadline_1)

    ##pipeline_2 = ut.generateUrgentPipeline(dax2,
    ##                                       wf_start_id_2,
    ##                                       task_postfix_id_2,
    ##                                       deadline_2)
    common_pipeline = pipeline_1 ## + pipeline_2

    rgen = ResourceGenerator()
    resources = rgen.generate()
    transferMx = rgen.generateTransferMatrix(resources)

    estimator = ExperimentEstimator(transferMx)

    planner = StaticHeftPlanner()
    planner.estimator = estimator
    planner.resource_manager = ExperimentResourceManager(resources)
    planner.workflows = common_pipeline

    schedule = planner.schedule()

    print("planner.global_count: " + str(planner.global_count))

class QuantExperiment(TestCase):

    def test_quant(self):

        ##cProfile.run('wrap()')

        pr = cProfile.Profile()
        pr.enable()
        wrap()
        pr.disable()
        s = io.StringIO()
        sortby = 'cumulative'
        ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
        ps.print_stats()
        print(s.getvalue())

        ##TODO: fake run remake it later.
        self.assertTrue(True)
if __name__ == '__main__':
    unittest.main()
